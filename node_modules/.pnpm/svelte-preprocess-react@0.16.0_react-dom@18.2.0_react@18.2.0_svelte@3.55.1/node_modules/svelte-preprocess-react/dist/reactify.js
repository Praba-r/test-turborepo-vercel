import * as React from "react";
import SvelteWrapper from "./internal/SvelteWrapper.svelte";
import SvelteToReactContext from "./internal/SvelteToReactContext.js";
/**
 * Convert a Svelte component into a React component.
 */
export default function reactify(SvelteComponent) {
    const { name } = SvelteComponent;
    const named = {
        [name](options) {
            const { children } = options;
            const props = extractProps(options);
            const events = extractListeners(options);
            const wrapperRef = React.useRef();
            const svelteRef = React.useRef();
            const slotRef = React.useRef();
            const childrenRef = React.useRef();
            const context = React.useContext(SvelteToReactContext);
            // Mount Svelte component
            React.useEffect(() => {
                const target = wrapperRef.current;
                if (!target) {
                    return undefined;
                }
                const component = new SvelteWrapper({
                    target,
                    props: {
                        SvelteComponent: SvelteComponent,
                        children: detectChildren(children),
                        props,
                        events,
                    },
                    context,
                });
                component.$on("svelte-slot", ({ detail: el }) => {
                    if (el && childrenRef.current) {
                        el.appendChild(childrenRef.current);
                    }
                    slotRef.current = el;
                });
                svelteRef.current = component;
                return () => {
                    component.$destroy();
                };
            }, [wrapperRef]);
            // Sync props & events
            React.useEffect(() => {
                if (svelteRef.current) {
                    svelteRef.current.$set({ props, events });
                }
            }, [props, svelteRef]);
            // Sync children/slot
            React.useEffect(() => {
                if (childrenRef.current) {
                    if (slotRef.current &&
                        childrenRef.current.parentElement !== slotRef.current) {
                        slotRef.current.appendChild(childrenRef.current);
                    }
                }
                else if (slotRef.current) {
                    slotRef.current.innerHTML = "";
                }
            }, [childrenRef]);
            const ssr = SvelteComponent;
            if (ssr.render) {
                const $$slots = {};
                if (typeof children === "string") {
                    $$slots.default = () => children;
                }
                const result = ssr.render(props, {
                    context,
                    $$slots,
                });
                return React.createElement("svelte-wrapper", {
                    style: {
                        display: "contents",
                    },
                    dangerouslySetInnerHTML: { __html: result.html },
                });
            }
            return React.createElement("svelte-wrapper", {
                ref: wrapperRef,
                style: { display: "contents" },
            }, children
                ? React.createElement("react-children", {
                    ref: childrenRef,
                    style: { display: "contents" },
                }, children)
                : undefined);
        },
    };
    return named[name];
}
function extractProps(options) {
    const props = {};
    Object.entries(options).forEach(([prop, value]) => {
        if (prop !== "children" && isEventProp(prop) === false) {
            props[prop] = value;
        }
    });
    return props;
}
function extractListeners(options) {
    const listeners = {};
    Object.entries(options).forEach(([prop, value]) => {
        if (isEventProp(prop)) {
            listeners[prop[2].toLowerCase() + prop.slice(3)] = value;
        }
    });
    return listeners;
}
function isEventProp(prop) {
    return /^on[A-Z]/.test(prop);
}
function detectChildren(children) {
    if (children === undefined) {
        return false;
    }
    if (Array.isArray(children) && children.length === 0) {
        return false;
    }
    return true;
}
